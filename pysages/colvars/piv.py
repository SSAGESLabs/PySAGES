# SPDX-License-Identifier: MIT
# Copyright (c) 2020-2021: PySAGES contributors
# See LICENSE.md and CONTRIBUTORS.md at https://github.com/SSAGESLabs/PySAGES

"""
Implementation of Permutation Invariant Vector (PIV) as described in 
[Handb. Mater. Model.: Theor. and Model., 597-619 (2020)]
(https://doi.org/10.1007/978-3-319-44677-6_51) by Fabio Petrucci
"""

from jax import numpy as np, vmap

from pysages.colvars.core import CollectiveVariable
from pysages.colvars import coordinates
from pysages.colvars.utils import rational_switching_function

import numpy as onp
        
class PIV(CollectiveVariable):
    """
    Permutation Invariant Vector (PIV) of a given system of points 
    in space as described in Section 4 of 
    [Handb. Mater. Model.: Theor. and Model., 597-619 (2020)]
    (https://doi.org/10.1007/978-3-319-44677-6_51).

    PIV collective variable is generated by using the user-defined 
    points in space. These points are typically the coordinates 
    of solute and solvent. Single or multiple solutes in a given 
    solvent are supported. For determining solvent atoms in a solvation 
    shell around solute, 
    [JAX MD](https://jax-md.readthedocs.io/en/main/jax_md.partition.html) 
    neighborlist library is utilized. This requires the user
    to define the indices of all the atoms in the system and a JAX MD 
    neighbor list callable
    (see alanine dipeptide example in examples/openmm/metad/pivcv) for
    updating the neighbor list.
    
    solute-solute blocks of the PIV are determined by using the indices 
    of the solute pairs generated by the user. To sort solute-solute blocks 
    and solute-solvent blocks, user need to provide the indices of all 
    solute atoms and oxygen atoms in two separate lists. The indices 
    of the hydrogen atoms bonded to the oxygen atoms are determined 
    by using the oxygen-hydrogen dictionary generated by the user using
    a PDB file of the system configuration.
    
    The switching function parameters parameters for each block 
    should be provided as a list of dictionaries.
    
    Example PIV CV definition:
        cvs = [PIV( all_atoms, position_pairs, solute_list, oxygen_list,
        hydrogen_array, [{'r_0': 0.4, 'd_0': 2.3, 'n': 3, 'm': 6}, ...],
        {'neighbor_list': gen_neighbor_list()})]
    
    Parameters
    ----------
    allatoms: list
            List of indices of all atoms required for updating neighbor list.
    position_pairs: JaxArray
            Array containing indices of solute-solute pairs for the solute-solute
            block of PIV.
    solute_array: JaxArray
            Indices of all solute atoms
    oxygen_array: JaxArray
            Indices of all oxygen atoms
    hydrogen_array: JaxArray
            Dictionary mapping each oxygen in water with their hydrogen atoms.
    switching_params: list[dict]
            List of dictionaries containing switching function parameters for each
            PIV block.
    neighbor_list: Callable
            JAX MD neighbor list function to update the neighbor list.
            
    Returns
    -------
    piv: JaxArray
        Permutation Invariant Vector (PIV)
    """
    
    def __init__(self, indices, position_pairs, solute_array, solvent_oxygen_array,
                 hydrogen_array, switching_params, update_neighborlist):
        super().__init__(indices, group_length=None)
        self.position_pairs = position_pairs
        self.solute_array = solute_array
        self.solvent_oxygen_array = solvent_oxygen_array
        self.hydrogen_array = hydrogen_array
        self.switching_params = switching_params
        self.update_neighborlist = update_neighborlist['update_neighborlist']
        
        self.time = 0
        print("simulation timestep init, 0")
        
    @property
    def function(self):
        """
        Function generator

        Returns
        -------
        Function that generates PIV from a simulation snapshot.
        Look at `pysages.colvars.ann.piv` for details.
        """
        return lambda positions: piv(positions, self.update_neighborlist, self.time, self)
        

def piv(positions, update_neighborlist, time, params):
    """
    Implementation of permutation invariant vector as described in
    [Section 4, Handb. Mater. Model. 597-619 (2020)]
    (https://doi.org/10.1007/978-3-319-44677-6_51) by Fabio Petrucci.

    Parameters
    ----------
    positions: JaxArray
            Contains positions of all atoms in the system.
    update_neighborlist: Callable
            Function to update neighbor list.
    params: Object
        Links to all the helper parameters. This includes
        solute-solute pair indices, solvent oxygen indices,
        solvent hydrogen indices, and
        switching function parameters.

    Returns
    -------
    piv : DeviceArray
        Permutation Invariant Vector (PIV).
    """
    
    all_atom_positions = np.array(positions)
    
    update_neighborlist = update_neighborlist.update(all_atom_positions)
    
    print("neighbor list state:\n")
    print("time is " + str(time))
    time += 1
    print(update_neighborlist.idx)
    print(update_neighborlist.reference_position)
    print(update_neighborlist.did_buffer_overflow)
    print(update_neighborlist.cell_list_capacity)
    print(update_neighborlist.max_occupancy)
    print(update_neighborlist.format)
    print(update_neighborlist.update_fn)
    print("\n")    
    
    position_pairs = params.position_pairs 
    solute_list = params.solute_array
    solvent_oxygen_list = params.solvent_oxygen_array
    hydrogen_array = params.hydrogen_array    
    
    i_pos = all_atom_positions[position_pairs[:,1]]
    j_pos = all_atom_positions[position_pairs[:,3]]
    
    piv_solute_blocks = vmap(get_piv_block, in_axes=(0, 0, None))(i_pos, j_pos, params.switching_params)
    piv_solute_block_index = vmap(cantor_pair, in_axes=(0, 0))(position_pairs[:,0], position_pairs[:,2])
    
    idx_solute_sort = np.argsort(piv_solute_block_index)
    piv_solute_blocks = piv_solute_blocks[idx_solute_sort]

    if solvent_oxygen_list:
        
        nlist = update_neighborlist.idx
        atom_ids = np.arange(np.shape(nlist)[0])[:, np.newaxis]
        atom_ids_nlist = np.hstack((atom_ids, nlist))
        solute_atom_ids_nlist = atom_ids_nlist[np.array(solute_list).flatten()]
        oxygen_array = solute_atom_ids_nlist[:,1:]
        solute_array = solute_atom_ids_nlist[:,0]
        solute_array = np.repeat(solute_array, np.shape(oxygen_array)[1])
        solute_array = np.reshape(solute_array, np.shape(oxygen_array))
        solute_array = solute_array[:, :, np.newaxis]
        block_ids = np.arange(np.shape(solute_list)[0])
        block_ids = np.repeat(block_ids, np.shape(oxygen_array)[1])
        block_ids =  np.reshape(block_ids, np.shape(oxygen_array))
        block_ids = block_ids[:, :, np.newaxis]
        
        
        hydrogen_array = hydrogen_array[oxygen_array.flatten()]
        hydrogen_array = np.array(hydrogen_array, dtype=int)
        hydrogen_array = np.reshape(hydrogen_array, (*np.shape(oxygen_array)[:2], 2))
        

        
        solute_atom_ids_nlist = np.dstack((block_ids, solute_array, 
                                           oxygen_array, hydrogen_array)).reshape(-1,5)

        
        i_pos = all_atom_positions[solute_atom_ids_nlist[:,1]]
        j_pos = all_atom_positions[solute_atom_ids_nlist[:,2]]
        piv_solute_solvent_blocks = vmap(get_piv_block, in_axes=(0, 0, None))(i_pos, j_pos, params.switching_params)
        piv_solute_solvent_block_index = solute_atom_ids_nlist[:,0]
        idx_solvent_sort = np.argsort(piv_solute_solvent_block_index)
        piv_solute_solvent_blocks = piv_solute_solvent_blocks[idx_solvent_sort]
        piv_solute_solvent_blocks = piv_solute_solvent_blocks.flatten()
        
        
        piv_blocks = np.concatenate( (piv_solute_blocks, piv_solute_solvent_blocks), axis=0)
                     

    else:
        
        piv_blocks = piv_solute_blocks
        
    return piv_blocks[0]
    
    
def get_piv_block(i_pos, j_pos, switching_params):
    
    r_0 = switching_params['r_0']
    d_0 = switching_params['d_0']
    n = switching_params['n']
    m = switching_params['m']
    
    r = coordinates.distance(i_pos, j_pos)
    s_r = rational_switching_function(r, r_0, d_0, n, m)
    
    return s_r
    
    
def cantor_pair(int1, int2):
    """
    Generates an uniuqe integer using two integers via Cantor pair function.
    This unique integer can be mapped back to the two integers, if needed.
    """
    
    pi = int1 + int2
    pi = pi * (pi + 1)
    pi *= 0.5
    pi += int2
    
    return np.int32(pi)