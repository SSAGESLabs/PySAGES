# SPDX-License-Identifier: MIT
# See LICENSE.md and CONTRIBUTORS.md at https://github.com/SSAGESLabs/PySAGES

"""
Collective variable related to native contacts.

Q describes the fraction of the native contacts
for folding of proteins or nucleic acids
"""
from jax import numpy as np

from pysages.colvars.core import CollectiveVariable


def remap_indices(contacts, sorted_unique_indices):
    # Generate the mapping by using argsort on sorted_unique_indices
    old_indices = np.array(sorted_unique_indices)
    new_indices = np.argsort(old_indices)

    index_mapping = np.zeros(old_indices[-1] + 1, dtype=int)
    index_mapping.at[old_indices].set(new_indices)

    contacts = np.array(contacts)
    remapped_contacts = index_mapping[contacts]

    return remapped_contacts


class NativeContactFraction(CollectiveVariable):
    """
    Calculate the native contact fraction Q.

    Parameters
    ------------
    indices: list[int]
        List of the indices of the atoms of interests.
        indices should be equal to unique(contact_pairs)
    contact_pairs: list[tuple(int)]
        List of pairs of indices of atoms (list of contacts) to be considered.
        The overall shape should be (n_contacts, 2).
        These pairs are usually generated by a cutoff radius.
        For example, in a system with 5 atoms, if in the reference structure,
        only 2-3, 2-4 and 1-5 are in contact with each other,
        we should pass in [(2, 3), (2, 4), (1, 5)]
    reference: list[tuple(float)]
        Reference coordinates for the selected atoms.
    gamma: float
        Smoothing parameter. Default is 50 nm^-1.
    lambda_d: float
        Scaling factor for the distances.
    """

    def __init__(self, indices, contact_pairs, references, gamma=50, lambda_d=1.5):
        super().__init__(indices)
        indices = np.sort(np.asarray(indices))
        contact_pairs = np.asarray(contact_pairs)
        assert all(
            indices == np.unique(contact_pairs)
        ), "contact pairs should contain and only contain index from indices"
        assert not np.any(
            contact_pairs[:, 0] == contact_pairs[:, 1]
        ), "contact pairs contain self-self interaction"
        self.contact_pairs = remap_indices(contact_pairs, indices)

        self.references = np.asarray(references)
        self.gamma = gamma
        self.lambda_d = lambda_d

    @property
    def function(self):
        return lambda r: native_contact_fraction(
            r, self.contact_pairs, self.references, self.gamma, self.lambda_d
        )


def native_contact_fraction(r, contact_pairs, references, gamma, lambda_d):
    r"""
    Calculate the native contact fraction Q.

    Parameters
    ----------
    r: (n_atoms, 3) array
        Current positions of the atoms.
    contact_pairs: (n_contacts, 2) array
        pairs of indices of atoms that are in contact.
    references: (n_atoms, 3) array
        Reference contact distances.
    gamma: float
        Smoothing parameter.
    lambda_d: float
        Scaling factor for the distances.

    Returns
    -------
    Q: float
        Native contact fraction.

    Mathematical details can be found in
    [Best, Mittal, JPCB, 2010](https://pubs.acs.org/doi/10.1021/jp102575b)
    :math:`Q=\frac{1}{N_\mathrm{contacts}}\sum_{(i, j)} \frac{1}{1+\exp(\gamma(r_{ij}-r_{ij}^0))}`

    """
    # Calculate pairwise distances
    distance_matrix = r[:, None, :] - r[None, :, :]
    N = distance_matrix.shape[0]
    diagonal_indices = np.arange(N), np.arange(N)
    mask_val = 100  # mask trick to avoid divergence
    mask_array = np.array([mask_val, mask_val, mask_val])
    distance_matrix = distance_matrix.at[diagonal_indices].set(mask_array)
    distances = np.linalg.norm(distance_matrix, axis=-1)

    reference_distance_matrix = references[:, None, :] - references[None, :, :]
    reference_distance_matrix = reference_distance_matrix.at[diagonal_indices].set(mask_array)
    reference_distances = np.linalg.norm(reference_distance_matrix, axis=-1)

    distances_contacts = distances[contact_pairs[:, 0], contact_pairs[:, 1]]
    reference_distances_contacts = reference_distances[contact_pairs[:, 0], contact_pairs[:, 1]]
    diff = distances_contacts - lambda_d * reference_distances_contacts
    Q_contribution = 1 / (1 + np.exp(gamma * diff))

    N_contacts = contact_pairs.shape[0]

    return np.sum(Q_contribution) / N_contacts
