# SPDX-License-Identifier: MIT
# See LICENSE.md and CONTRIBUTORS.md at https://github.com/SSAGESLabs/PySAGES

"""
Collective variable related to native contacts.

Q describes the fraction of the native contacts
for folding of proteins or nucleic acids
"""
from jax import numpy as np

from pysages.colvars.core import CollectiveVariable


def remap_indices(contacts, sorted_unique_indices):
    # Generate the mapping by using argsort on sorted_unique_indices
    old_indices = np.array(sorted_unique_indices)
    new_indices = np.argsort(old_indices)

    index_mapping = np.zeros(old_indices.max() + 1, dtype=new_indices.dtype)
    index_mapping = index_mapping.at[old_indices].set(new_indices)

    contacts = np.array(contacts)
    remapped_contacts = index_mapping[contacts]

    return remapped_contacts


class NativeContactFraction(CollectiveVariable):
    r"""
    Calculate the native contact fraction Q.

    Parameters
    ------------
    indices: list[int]
        List of the indices of the atoms of interests.
        indices should be equal to unique(contact_pairs)
    contact_pairs: list[tuple(int)]
        List of pairs of indices of atoms (list of contacts) to be considered.
        The overall shape should be (n_contacts, 2).
        These pairs are usually generated by a cutoff radius.
        For example, in a system with 5 atoms, if in the reference structure,
        only 2-3, 2-4 and 1-5 are in contact with each other,
        we should pass in [(2, 3), (2, 4), (1, 5)]
    reference: list[tuple(float)]
        Reference coordinates for the selected atoms.
    gamma: float
        Smoothing parameter. Default is 50 nm^-1.
    lambda_d: float
        Scaling factor for the distances.
    clip: bool
        Clip the :math:`\gamma(r_{ij}-\lambda_d*r_{ij}^0)` by some value.
        Default is False
    clip_val: float
        Default is 5.
    """

    def __init__(
        self, indices, contact_pairs, references, gamma=50, lambda_d=1.5, clip=False, clip_val=5
    ):
        super().__init__(indices)
        indices = np.sort(np.asarray(indices))
        contact_pairs = np.asarray(contact_pairs)
        assert all(
            indices == np.unique(contact_pairs)
        ), "contact pairs should contain and only contain index from indices"
        assert not np.any(
            contact_pairs[:, 0] == contact_pairs[:, 1]
        ), "contact pairs contain self-self interaction"
        self.contact_pairs = remap_indices(contact_pairs, indices)

        self.references = np.asarray(references)
        self.gamma = gamma
        self.lambda_d = lambda_d
        self.clip = clip
        self.clip_val = clip_val

    @property
    def function(self):
        return lambda r: native_contact_fraction(
            r,
            self.contact_pairs,
            self.references,
            self.gamma,
            self.lambda_d,
            self.clip,
            self.clip_val,
        )


def native_contact_fraction(r, contact_pairs, references, gamma, lambda_d, clip, clip_val):
    r"""
    Calculate the native contact fraction Q.
    Mathematical details can be found in
    [Best, Mittal, JPCB, 2010](https://pubs.acs.org/doi/10.1021/jp102575b)

    :math:`Q=\frac{1}{N_\mathrm{contacts}}\sum_{(i, j)} \
    \frac{1}{1+\exp(\gamma(r_{ij}-\lambda_d r_{ij}^0))}`

    Parameters
    ----------
    r: (n_atoms, 3) array
        Current positions of the atoms.
    contact_pairs: (n_contacts, 2) array
        pairs of indices of atoms that are in contact.
    references: (n_atoms, 3) array
        Reference contact distances.
    gamma: float
        Smoothing parameter.
    lambda_d: float
        Scaling factor for the distances.
    clip: bool
        Clip the :math:`\gamma(r_{ij}-\lambda_d*r_{ij}^0)` by some value.
    clip_val: float
        clip value

    Returns
    -------
    Q: float
        Native contact fraction.


    """
    # Calculate pairwise distances
    distance_matrix = r[:, None, :] - r[None, :, :]
    N = distance_matrix.shape[0]
    diagonal_indices = np.arange(N), np.arange(N)
    mask_val = 100  # mask trick to avoid divergence
    mask_array = np.array([mask_val, mask_val, mask_val])
    distance_matrix = distance_matrix.at[diagonal_indices].set(mask_array)
    distances = np.linalg.norm(distance_matrix, axis=-1)

    reference_distance_matrix = references[:, None, :] - references[None, :, :]
    reference_distance_matrix = reference_distance_matrix.at[diagonal_indices].set(mask_array)
    reference_distances = np.linalg.norm(reference_distance_matrix, axis=-1)

    distances_contacts = distances[contact_pairs[:, 0], contact_pairs[:, 1]]
    reference_distances_contacts = reference_distances[contact_pairs[:, 0], contact_pairs[:, 1]]
    diff = gamma * (distances_contacts - lambda_d * reference_distances_contacts)
    if clip:
        diff = np.clip(diff, None, clip_val)
    Q_contribution = 1 / (1 + np.exp(diff))

    N_contacts = contact_pairs.shape[0]

    return np.sum(Q_contribution) / N_contacts
