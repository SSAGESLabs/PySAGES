# SPDX-License-Identifier: GPL-3.0-or-later
# See LICENSE.md and CONTRIBUTORS.md at https://github.com/SSAGESLabs/PySAGES

"""
Funnel Adaptive Biasing Force (Funnel_ABF) sampling method.

ABF partitions the collective variable space into bins determined by a user
provided grid, and keeps a tabulation of the number of visits to each bin
as well as the sum of generalized forces experienced by the system at each
configuration bin. These provide an estimate for the mean generalized force,
which can be integrated to yield the free energy. This update allows to include
 external restraint and accurately remove their contribution in the free energy
 calculations.

"""

from jax import jit
from jax import numpy as np
from jax.lax import cond

from pysages.grids import build_indexer
from pysages.methods.core import GriddedSamplingMethod, Result, generalize
from pysages.methods.restraints import apply_restraints
from pysages.typing import JaxArray, NamedTuple
import pysages
from pysages.utils import dispatch

class UnbiasState(NamedTuple):
    """
    Funnel_ABF internal state.

    Parameters
    ----------

    xi: JaxArray (CV shape)
        Last collective variable recorded in the simulation.

    bias: JaxArray (Nparticles, d)
        Array with biasing forces for each particle.

    """

    xi: JaxArray
    bias: JaxArray
    zero: JaxArray

    def __repr__(self):
        return repr("PySAGES " + type(self).__name__)


class Unbias(GriddedSamplingMethod):
    """
    Funnel with Unbias.

    Attributes
    ----------

    snapshot_flags:
        Indicate the system properties required from a snapshot.

    Parameters
    ----------

    cvs: Union[List, Tuple]
        Set of user selected collective variable.

    grid: Grid
        Specifies the collective variables domain and number of bins for
        discretizing the CV space along each CV dimension.
    
    restraints: Optional[CVRestraints] = None
        If provided, indicate that harmonic restraints will be applied when any
        collective variable lies outside the box from `restraints.lower` to
        `restraints.upper`.

    """

    snapshot_flags = {"positions", "indices", "momenta"}

    def __init__(self, cvs, grid, **kwargs):
        super().__init__(cvs, grid, **kwargs)

    def build(self, snapshot, helpers, *args, **kwargs):
        """
        Build the functions for the execution of ABF

        Parameters
        ----------

        snapshot:
            PySAGES snapshot of the simulation (backend dependent).

        helpers:
            Helper function bundle as generated by
            `SamplingMethod.context[0].get_backend().build_helpers`.

        Returns
        -------

        Tuple `(snapshot, initialize, update)` to run ABF simulations.
        """
        self.ext_force = self.kwargs.get("ext_force", None)
        return _Unbias(self, snapshot, helpers)


def _Unbias(method, snapshot, helpers):
    """
    Internal function that generates the init and update functions.

    Parameters
    ----------

    method: ABF
        Class that generates the functions.
    snapshot:
        PySAGES snapshot of the simulation (backend dependent).
    helpers
        Helper function bundle as generated by
        `SamplingMethod.context[0].get_backend().build_helpers`.

    Returns
    -------
    Tuple `(snapshot, initialize, update)` to run Unbias bias simulations.
    """
    cv = method.cv
    grid = method.grid
    dims = grid.shape.size
    natoms = np.size(snapshot.positions, 0)
    get_grid_index = build_indexer(grid)
    estimate_force = build_force_estimator(method)
    ext_force = method.ext_force

    def initialize():
        """
        Internal function that generates the first FABFState
        with correctly shaped JaxArrays.

        Returns
        -------
        FABFState
            Initialized State
        """
        xi, _ = cv(helpers.query(snapshot))
        bias = np.zeros((natoms, helpers.dimensionality()))
        zero = np.zeros((natoms, helpers.dimensionality()))
        return UnbiasState(xi, bias, zero)

    def update(state, data):
        """
        Advance the state of the Funnel_ABF simulation.

        Parameters
        ----------

        state: FABFstate
            Old FABFstate from the previous simutlation step.
        data: JaxArray
            Snapshot to access simulation data.

        Returns
        -------
        FABFState
            Updated internal state.
        """
        # Compute the collective variable and its jacobian
        xi, Jxi = cv(data)

        # Restraint force and logger
        e_f, proj = ext_force(data)
        # Second order backward finite difference
        I_xi = get_grid_index(xi)
        force = estimate_force(xi, I_xi, state.zero).reshape(dims)
        bias = np.reshape(-Jxi.T @ force, state.bias.shape) + np.reshape(-e_f, state.bias.shape)
        # Restraint contribution to force

        return UnbiasState(xi, bias, state.zero)

    return snapshot, initialize, generalize(update, helpers)


@dispatch
def build_force_estimator(method: Unbias):
    """
    Returns a function that computes the average forces
    (or the harmonic restraints forces if provided).
    """
    grid = method.grid

    def bias_force(data):
        _, zero = data
        return zero

    if method.restraints is None:
        estimate_force = jit(lambda *args: bias_force(args))
    else:
        lo, hi, kl, kh = method.restraints

        def restraints_force(data):
            xi, _ = data
            xi = xi.reshape(grid.shape.size)
            return apply_restraints(lo, hi, kl, kh, xi)

        def estimate_force(xi, I_xi, zero):
            ob = np.any(np.array(I_xi) == grid.shape)  # Out of bounds condition
            data = (xi, zero)
            return cond(ob, restraints_force, bias_force, data)

    return estimate_force
